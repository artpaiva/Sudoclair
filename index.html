<html>
<head>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400&display=swap" rel="stylesheet">
<style>
* {
	box-sizing: border-box;
	margin: 0;
	padding: 0;
}
body {
	font-family: 'Montserrat', sans-serif;
}
.puzzle-wrapper{
	width: 500px;
	margin: 1rem auto;
	text-align: center;
}
.sudoku-grid {
	border-collapse: collapse;
}
.sudoku-box {
	border-collapse: collapse;
	border: 2px solid #BBB;
}
.sudoku-box table{
	padding: 0;
	border-collapse: collapse;
}
.sudoku-box td{
	border-collapse: collapse;
	width: 2.8rem;
	height: 2.8rem;
	border: 1px solid #CCC;
	color: #AAA;
	text-align: center;
	vertical-align: middle;
	transition: 0.3s;
}
.sudoku-box td:hover{
	background: #00000007;
}
.cell-input{
	cursor: pointer;
	width: 100%;
	height: 100%;
	border: 0;
	outline: 0;
	background: transparent; 
	color: #444;
	font-family: 'Montserrat', sans-serif;
	font-size: 1.1rem;
	text-align: center;
	transition: 0.3s;
}
.cell-input[type=number] {
  -moz-appearance: textfield;
}
.cell-input::-webkit-outer-spin-button,
.cell-input::-webkit-inner-spin-button {
  -webkit-appearance: none;
  margin: 0;
}
.cell-input:focus{
	background: #00000705; 
}
table tr:first-child td {
  border-top: 0;
}
table tr td:first-child {
  border-left: 0;
}
table tr:last-child td {
  border-bottom: 0;
}
table tr td:last-child {
  border-right: 0;
}

.button-solve {
	margin: 1rem auto;
	padding: 0.4rem 1.6rem;
	border: 2px solid #444;
	color: #444;
	font-size: 1.2rem;
}
</style>
</head>
<body>
	<div class="puzzle-wrapper">
		<button class="button-solve" onclick="solve()">Test it!</button>
	</div>
</body>
<script type="text/javascript">
var wrapper = document.querySelector('.puzzle-wrapper');

var source = [];
var custom = [];
function initGrid () {
	/*for (var i = 0; i < 9; i++) {
		source[i] = [];
		for (var j = 0; j < 9; j++) {
			source[i][j] = 0;
		}
	}*/
	// source = puzzlefy(source);

	// Sample Sudoku board
	source[0] = [6, 0, 9, 0, 0, 8, 3, 0, 2];
	source[1] = [0, 5, 0, 6, 2, 0, 7, 0, 0];
	source[2] = [0, 0, 7, 9, 0, 0, 0, 0, 0];
	source[3] = [5, 0, 0, 0, 1, 0, 2, 6, 0];
	source[4] = [0, 6, 0, 0, 0, 5, 0, 0, 0];
	source[5] = [7, 0, 0, 0, 0, 2, 0, 0, 0];
	source[6] = [9, 7, 6, 0, 0, 0, 0, 0, 1];
	source[7] = [4, 1, 5, 0, 0, 0, 6, 3, 7];
	source[8] = [2, 0, 0, 0, 0, 0, 5, 9, 4];
	for (var i = 0; i < 9; i++) {
		custom[i] = [];
		for (var j = 0; j < 9; j++) {
			custom[i][j] = source[i][j];
		}
	}
}

function puzzlefy (matrix) {
	var size = 9;
	var mize = 3;
	var options = [1, 2, 3, 4, 5, 6, 7, 8, 9];
	var all = [];
	for (var q = 0; q < size*size; q++) {
		all[q] = q+1;
	}
	for (var p = 0; p < options.length; p++) {
		var n = options[p];
		
	}
	/*for (var i = 0; i < 9; i++) {
		for (var j = 0; j < 9; j++) {
			var temp = [];
			for (var z = 0; z < options.length; z++) {
				temp[z] = options[z];
			}
			var can = false;
			var value = temp[0];
			console.log(`Row: ${i}, Column ${j}`);
			do {
				var r = Math.floor(Math.random() * temp.length);
				value = temp[r];
				var found = false;

				// Searches for an equal value on this column, row, if it finds, removes the value from the possible values
				// Row
				if (!found)
				for (var a = 0; a < 9; a++) {
					if (value == matrix[a][j]) {
						found = true;
						temp.splice(r, 1);
						console.log(temp);
					}
				}
				// Column
				if (!found)
				for (var b = 0; b < 9; b++) {
					if (value == matrix[i][b]) {
						found = true;
						temp.splice(r, 1);
						console.log(temp);
					}
				}

				if (!found || temp.length == 0) {
					can = true;
					console.log(value);
				}
			} while (!can);

			matrix[i][j] = value;
		}
	}*/
	return matrix;
}

function renderGrid () {
	initGrid();
	var grid = document.createElement('table');
	grid.className = 'sudoku-grid';
	for (var i = 0; i < 3; i++) {
		var row = document.createElement('tr');
		for (var j = 0; j < 3; j++) {

			var boxtd = document.createElement('td');
			var box = document.createElement('table');
			boxtd.className = 'sudoku-box';
			for (var x = 0; x < 3; x++) {
				var line = document.createElement('tr');
				for (var y = 0; y < 3; y++) {
					var cell = document.createElement('td');
					var ro = i*3 + x;
					var co = j*3 + y;
					var inside = document.createElement(source[ro][co] == 0 ? 'input' : 'span');
					inside.className = source[ro][co] == 0 ? 'cell-input' : 'cell-span';
					inside.innerHTML = source[ro][co] == 0 ? '' : source[ro][co];
					inside.type = 'number';
					inside.maxLength = '1';
					inside.min = '1';
					inside.max = '9';
					cell.appendChild(inside);
					line.appendChild(cell);
				}
				box.appendChild(line);
			}
			boxtd.appendChild(box);
			row.appendChild(boxtd);

		}
		grid.appendChild(row);
	}
	wrapper.appendChild(grid);

}
renderGrid();


function solve () {
	console.log('Testing it!');
	var current = [];
	for (var i = 0; i < 9; i++) {
		current[i] = [];
		for (var j = 0; j < 9; j++) {
			current[i][j] = source[i][j];
		}
	}
	// Sets all possible candidate for each cell
	var candidacy = [];
	for (var i = 0; i < 9; i++) {
		candidacy[i] = [];
		for (var j = 0; j < 9; j++) {
			candidacy[i][j] = [];
			if ( source[i][j] == 0 ) {
				candidacy[i][j] = [1, 2, 3, 4, 5, 6, 7, 8, 9]
			} else {
				candidacy[i][j][0] = source[i][j];
			}
		}
	}
	var stop = false;
	var icandidacy = [];
	do {
		for (var i = 0; i < 9; i++) {
			icandidacy[i] = [];
			for (var j = 0; j < 9; j++) {
				icandidacy[i][j] = [];
				for (var c = 0; c < candidacy[i][j].length; c++) {
					icandidacy[i][j][c] = candidacy[i][j][c];
				}
			}
		}
		candidacy = pruneCandidacy(current, candidacy);
		current = unique(current, candidacy);
		current = soleCandidate(current, candidacy);
		stop = icandidacy.equals(candidacy);
		console.log(stop);
	} while(!stop)
	console.log(candidacy);
	console.log(current);
}
function pruneCandidacy (matrix, candidacy) {
	for (var i = 0; i < 9; i++) {
		for (var j = 0; j < 9; j++) {
			//if (candidacy[i][j].length > 0)
			for (var c = 0; c < candidacy[i][j].length; c++) {
				//Prune by Row
				//Run through the row to see if there's any candidates to be removed
				var candidate = candidacy[i][j][c];
				for (var y = 0; y < 9; y++) {
					if (y != i) {
						if (candidate == matrix[y][j] && candidate == candidacy[i][j][c]) {
							candidacy[i][j].splice(c, 1);
							c--;
						}
					}
				}
				//Prune by Column
				for (var x = 0; x < 9; x++) {
					if (x != j) {
						if (candidate == matrix[i][x] && candidate == candidacy[i][j][c]) {
							candidacy[i][j].splice(c, 1);
							c--;
						}
					}
				}
				//Prune by Box
				var boxy = Math.floor(i/3)*3;
				var boxx = Math.floor(j/3)*3;
				for (var y = boxy; y < boxy+3; y++) {
					for (var x = boxx; x < boxx+3; x++) {
						if (x != j && y != i) {
							if (candidate == matrix[y][x] && candidate == candidacy[i][j][c]) {
								candidacy[i][j].splice(c, 1);
								c--;
							}
						}
					}
				}
			}
		}
	}
	return candidacy;
}
function unique (matrix, candidacy) {
	for (var i = 0; i < 9; i++) {
		for (var j = 0; j < 9; j++) {
			if (candidacy[i][j].length == 1) {
				matrix[i][j] = candidacy[i][j][0];
			}
		}
	}
	return matrix;
}
function soleCandidate (matrix, candidacy) {
	var options = [1, 2, 3, 4, 5, 6, 7, 8, 9]
	//Checks row by row if each a candidacy is the only possible one in its row
	for (var n = 0; n < options.length; n++) {
		for (var i = 0; i < 9; i++) {
			var count = 0;
			var where = 0;
			for (var j = 0; j < 9; j++) {
				if (candidacy[i][j].includes(n)) {
					count++;
					where = j;
				}
			}
			if (count == 1) {
				//console.log(`row[${i}], column[${where}] is the only candidate in its row that can be a ${n}`);
				candidacy[i][where] = [];
				candidacy[i][where][0] = n;
				matrix[i][where] = n;
			}
		}
	}
	return matrix;
}

// Warn if overriding existing method
if(Array.prototype.equals)
    console.warn("Overriding existing Array.prototype.equals. Possible causes: New API defines the method, there's a framework conflict or you've got double inclusions in your code.");
// attach the .equals method to Array's prototype to call it on any array
Array.prototype.equals = function (array) {
    // if the other array is a falsy value, return
    if (!array)
        return false;

    // compare lengths - can save a lot of time 
    if (this.length != array.length)
        return false;

    for (var i = 0, l=this.length; i < l; i++) {
        // Check if we have nested arrays
        if (this[i] instanceof Array && array[i] instanceof Array) {
            // recurse into the nested arrays
            if (!this[i].equals(array[i]))
                return false;       
        }           
        else if (this[i] != array[i]) { 
            // Warning - two different object instances will never be equal: {x:20} != {x:20}
            return false;   
        }           
    }       
    return true;
}
// Hide method from for-in loops
Object.defineProperty(Array.prototype, "equals", {enumerable: false});

</script>
</html>
